\chapter{Kajian Pustaka}

\section{Categorial Grammar}
Categorial Grammar (CG) merupakan sebuah istilah yang mencakup beberapa formalisme terkait yang diajukan
untuk sintaks dan semantik dari bahasa alami serta untuk bahasa logis dan matematis \cite{Steedman92catg}.
Karakteristik yang paling terlihat dari CG adalah bentuk esktrim dari leksikalismenya di mana beban utama
(atau bahkan seluruh beban) sintaksisnya ditanggung oleh leksikon.
Konstituen tata bahasa dalam \textit{categorial grammar} dan khususnya semua leksikal diasosiasikan
dengan suatu \textit{type} atau \say{\textit{category}} (dalam \textit{category theory}) yang
mendefinisikan potensi mereka untuk dikombinasikan dengan konstituen lain untuk menghasilkan konstituen
majemuk.
\textit{Category} tersebut adalah salah satu dari sejumlah kecil \textit{category} dasar (seperti NP)
atau \textit{functor} (dalam \textit{category theory}).

Ada beberapa notasi berbeda untuk \textit{category} dalam merepresentasikan \textit{directional}-nya.
Notasi yang paling umum digunakan adalah \say{\textit{slash notation}} yang dipelopori oleh Bar-Hilel,
Lambek, dan kemudian dimodifikasi dalam kelompok teori yang dibedakan sebagai tata bahasa
\say{\textit{combinatory}} \textit{categorial grammar} (CCG).
Sebagai contoh, \textit{category} $\text{(S$\backslash$NP)/NP}$ merupakan suatu \textit{functor} yang
memiliki dua buah notasi \textit{slash} yaitu $\backslash$ dan $/$.
Masing-masing notasi \textit{slash} tersebut merepresentasikan \textit{directionality} yang berbeda.
Notasi \textit{forward slash}, $/$, mengindikasikan bahwa argumen dari suatu \textit{functor}
$\text{X}/\text{Y}$ ada di bagian kanan atau dengan kata lain $\text{Y}$.
Adapun \textit{backward slash}, $\backslash$, mengindikasikan bahwa argumen dari suatu \textit{functor}
$\text{X}\backslash\text{Y}$ ada di bagian kiri atau dengan kata lain $\text{X}$.
Demikian itu, penggunaan notasi \textit{slash} yang tepat sangat penting dikarenakan hal ini dapat
mempengaruhi konstituen dari hasil \say{kombinasi} \textit{category}-nya.

\section{Combinatory Categorial Grammar}
Combinatory Categorial Grammar (CCG) merupakan salah satu formalisme tata bahasa yang gaya aturannya
diturunkan dari \textit{categorial grammar} dengan beberapa penambahan aturan dan istilah baru.
Di CCG, \textit{category} dapat dipasangkan dengan \textit{semantic representation}.
Dalam hal ini, \textit{semantic representation} yang dimaksud adalah abstraksi fungsi lambda
(dalam \textit{lambda calculus}, \textit{lambda function}).
Sebagai contoh, \textit{category} $\text{(S$\backslash$NP)/NP}$ dapat dipasangkan dengan fungsi lambda
$\lambda{x. fx}$ sehingga dapat ditulis menjadi $\text{(S$\backslash$NP)/NP} : \lambda{x. fx}$.
Adapun pemetaan dari suatu token kata ke \textit{category}-nya menggunakan notasi $\vdash$.
Sebagai contoh, anggap saja kita memiliki kamus pemetaan seperti pada Gambar \ref{ccg:mapping:1}.
Apabila kita memiliki kalimat \say{Pamungkas dan Setyo menyukai rendang}, maka kita dapatkan:

\begin{figure}\centering\small
  \begin{align*}
    \text{Pamungkas} &\vdash \text{NP}: \so{pamungkas}\\
    \text{Setyo} &\vdash \text{NP}: \so{setyo}\\
    \text{dan} &\vdash \text{CONJ}: \lambda x.\lambda y.\lambda f.\ (f\ x) \land (f\ y)\\
    \text{menyukai} &\vdash \text{(S{$\backslash$}NP)/NP}: \lambda x.\lambda y.\ suka(y, x)\\
    \text{rendang} &\vdash \text{NP}: \so{rendang}
  \end{align*}
  \caption{Kamus yang memetakan token kata ke bentuk CCG \textit{lexicon}-nya.}
  \label{ccg:mapping:1}
\end{figure}

\begin{center}
  \bgroup
  \catcode`!=\active \def!{\upshape}
  \catcode`?=\active \def?#1{\makebox[0pt]{#1}}
  \catcode`^=\active \def^#1{\footnotesize{#1}}
  \catcode`*=\active \def*#1{\scriptsize{#1}}
  \tabbedShortstack{
    !^Pamungkas & & !^dan & & !^Setyo & & !^menyukai & & !^rendang &\\
    \TABcline{1,3,5,7,9}
    !^{$\text{NP}$} & &
      !^{$\text{CONJ}$} & &
      !^{$\text{NP}$} & &
      !^{$\text{(S$\backslash$NP)/NP}$} & &
      !^{$\text{NP}$} &\\
    !{*: \so{pamungkas}} & &
      !{*: $\lambda x.\lambda y.\lambda f.\ (f\ x) \land (f\ y)$} & &
      !{*: \so{setyo}} & &
      !{*: $\lambda x.\lambda y.\ suka(y, x)$} & &
      !{*: \so{rendang}} &
  }
  \egroup
\end{center}

Ada beberapa operasi yang dapat dilakukan dalam CCG. \textit{Operand} dari operasi
yang dimaksud adalah \textit{category}. Berdasarkan contoh di atas, akan ada tiga
operasi yang dijalankan yaitu \textit{coordination}, \textit{forward application},
dan \textit{type rising}.
Untuk mendapatkan hasil yang diinginkan, kita lakukan \textit{type rising} sebelum
\textit{forward application} di akhir.
Sehingga, kita dapatkan:

\begin{center}
  \bgroup
  \catcode`!=\active \def!{\upshape}
  \catcode`?=\active \def?#1{\makebox[0pt]{#1}}
  \catcode`^=\active \def^#1{\footnotesize{#1}}
  \catcode`*=\active \def*#1{\scriptsize{#1}}
  \tabbedLongunderstack{
    !^Pamungkas & & !^dan & & !^Setyo & & !^menyukai & & !^rendang &\\
    \TABcline{1,3,5,7,9}
    !^{$\text{NP}$} & &
      !^{$\text{CONJ}$} & &
      !^{$\text{NP}$} & &
      !^{$\text{(S$\backslash$NP)/NP}$} & &
      !^{$\text{NP}$} &\\
    !{*: \so{pamungkas}} & &
      !{*: $\lambda x.\lambda y.\lambda f.\ (f\ x) \land (f\ y)$} & &
      !{*: \so{setyo}} & &
      !{*: $\lambda x.\lambda y.\ suka(y, x)$} & &
      !{*: \so{rendang}} &\\
    \TABrule & \TABrule &
      \TABrule & \TABrule &
      \TABrule\CCGCOOR & &
      \TABrule & \TABrule &
      \TABrule\CCGFA &\\
    & &
      !?{^{$\text{NP}$}}
      \ \ \ \ \ \ \ \ \ 
      & & & &
      \ \ \ \ \ \ \ 
      !?{^{$\text{S$\backslash$NP}$}}
      & & &\\
    & &
      ?{*: $\lambda f.\ (f\ \so{pamungkas}) \land (f\ \so{setyo})$}
      \ \ \ \ \ \ \ \ \ 
      & & & &
      \ \ \ \ \ \ \ 
      ?{*: $\lambda y.\ suka(y, \so{rendang})$}
      & & &\\
    \TABrule & \TABrule &
      \TABrule & \TABrule &
      \TABrule\CCGTR & &
      & & &\\
    & &
      !?{^{$\text{S/(S$\backslash$NP)}$}}
      \ \ \ \ \ \ \ \ \ 
      & & & & & & &\\
    & &
      ?{*: $\lambda f.\ (f\ \so{pamungkas}) \land (f\ \so{setyo})$}
      \ \ \ \ \ \ \ \ \ 
      & & & & & & &\\
    \TABrule & \TABrule &
      \TABrule & \TABrule &
      \TABrule & \TABrule &
      \TABrule & \TABrule &
      \TABrule\CCGFA &\\
    & & &
      !?{^{$\text{S}$}}
      & & & & & &\\
    & & &
      ?{*: $suka(\so{pamungkas}, \so{rendang}) \land suka(\so{setyo}, \so{rendang})$}
      & & & & & &
  }
  \egroup
\end{center}

Berdasarkan hasil evaluasi tersebut, kita dapatkan \textit{query} \ref{ccg:query:1}
yang diperoleh dari kalimat \say{Pamungkas dan Setyo menyukai rendang}.
Demikian itu, komputer dapat melakukan komputasi berdasarkan \textit{query} yang telah diperoleh.
Kegiatan tersebut merupakan apa yang disebut dengan CCG \textit{parsing}.
Untuk dapat melakukan parsing, CCG \textit{lexicon} diperlukan.
Untuk mendapatkan CCG \textit{lexicon} kita dapat menggunakan CCG \textit{supertagger}
yang akan melakukan pelabelan suatu token kata ke CCG \textit{lexicon} berdasarkan
pemetaannya.

\begin{equation}\label{ccg:query:1}
  suka(\so{pamungkas}, \so{rendang}) \land suka(\so{setyo}, \so{rendang})
\end{equation}

\section{Category Theory}
\textit{Category Theory} (CT) merupakan formalisme yang dapat digunakan untuk memformalkan
struktur matematis.
CT mempelajari \textit{category} yang merupakan sebuah representasi dari suatu
abstraksi konsep matematis.
Suatu \textit{category} memiliki kumpulan \textit{object} dan \textit{morphism}.
Untuk mempermudah pemahaman mengenai CT, kita akan gunakan
\textit{category of set} (kategori dari himpunan) sebagai contoh.
Dalam \textit{category of set}, \textit{object}-nya adalah himpunan dan
\textit{morphism}-nya (terkadang disebut dengan \textit{arrow}) adalah fungsi
(\textit{function}, sebuah pemetaan).
Kemudian, pemetaan dari suatu \textit{category} $C$ ke \textit{category} $D$
yang dipetakan oleh $F$ ($F: C \rightarrow D$) disebut sebagai \textit{functor}.


\section{Lambda Calculus}
\textit{Lambda calculus} ({$\lambda$}\textit{-calculus}) merupakan sebuah formalisme yang dikembangkan
oleh Alonzo Church sebagai alat yang digunakan untuk memahami konsep komputasi yang efektif
\cite{DBLP:journals/corr/Rojas15}.
Formalisme {$\lambda$}\textit{-calculus} cukup populer dan bahkan dijadikan sebagai pondasi teori bagi
paradigma pemrograman \textit{functional programming}.
Konsep utama dari {$\lambda$}\textit{-calculus} adalah apa yang disebut dengan \textit{expression}.
Suatu \textit{expression} dalam {$\lambda$}\textit{-calculus} terdiri dari tiga bagian yaitu
\textit{lambda notation} ({$\lambda$}), \textit{argument} (seperti $a$, $b$, $c$, $x$, dan lain-lain),
dan \textit{body} yang dipisahkan dengan tanda titik.
Sebagai contoh, fungsi lambda ${\lambda}x. x$ merupakan sebuah fungsi identitas yang mengambil
argumen $x$ kemudian mengembalikan nilai $x$ itu sendiri.
Dalam hal ini, terlihat bahwa notasi {$\lambda$} merupakan sebuah penanda bagi suatu fungsi lambda.
Kemudian, pengubah $x$ setelah notasi {$\lambda$} merupakan argumen dari fungsi tersebut.
Selanjutnya, tanda titik merupakan pemisah antara \textit{head} dan \textit{body} fungsi lambda.
Terakhir, setelah tanda titik adalah \textit{body} dari suatu fungsi lambda yang mana berupa
\textit{expression}.

Untuk mempermudah pemahaman, {$\lambda$}\textit{-calculus} dapat diperlakukan seperti fungsi tanpa
nama. Sebagai contoh, fungsi lambda $({\lambda}x. x + 5)$ apabila diberikan nilai $2$ sehingga
menjadi $({\lambda}x. x + 5) 2$ akan dievaluasi menjadi ${\lambda}(2). (2) + 5$.
Demikian itu, nilai yang dikembalikan oleh fungsi tersebut adalah $7$.
Sama seperti fungsi pada umumnya, konsep ini bernama \textit{substition} (substitusi).
Memahami {$\lambda$}\textit{-calculus} dirasa perlu berhubung dalam tugas akhir ini
{$\lambda$}\textit{-calculus} digunakan sebagai bentuk formal di \textit{category}
dalam konteks CCG \textit{lexicon}. Meskipun {$\lambda$}\textit{-calculus} tidak sesederhana
yang dijelaskan sebelumnya, setidaknya memahami {$\lambda$}\textit{-calculus} seperti ini
sudah cukup untuk dapat membangun \textit{supertagger} yang ada di tugas akhir ini.


\section{Supertagging}
\textit{Supertagging} merupakan proses yang memetakan suatu token kata ke bentuk
\textit{supertag}-nya. CCG \textit{supertagging} artinya proses pemetaan dari suatu token
kata ke dalam bentuk CCG \textit{supertag} atau dapat juga disebut sebagai CCG \textit{lexicon}.
\textit{Supertag} mirip dengan POS \textit{tag}.
Perbedaannya, \textit{supertag} memiliki bentuk formalisme yang lebih kompleks dari POS
\textit{tag}.
Hal ini dikarenakan \textit{supertag} menyimpan informasi lain selain tanda gramatikalnya
($\text{NP}$, $\text{NN}$, $\text{VB}$, dan sebagainya).
Sebagai contoh, CCG \textit{supertag} memiliki bentuk dengan format:

\begin{equation*}
<\text{categorial\ grammar\ tag}>:\ <\text{semantic\ representation}>
\end{equation*}

Kita dapat menggunakan notasi $\vdash$ untuk memetakan token kata ke bentuk CCG
\textit{supertag}-nya.
Anggap kita memiliki kata kerja \say{menyukai} yang akan dipetakan ke
$\text{(S{$\backslash$}NP)/NP}: \lambda x.\lambda y.\ suka(y, x)$, kita dapatkan:

\begin{equation*}
  \text{menyukai} \vdash (S{\backslash}NP)/NP: \lambda x.\lambda y.\ suka(y, x)
\end{equation*}

Adapun sebuah \textit{tool} yang melakukan proses \textit{supertagging} ini dinamakan
\textit{supertagger}.
\textit{Supertagger} sederhananya mengambil daftar token kata yang kemudian untuk setiap
token kata tersebut \say{dilabelkan} dengan \textit{supertag}-nya.


\section{Maximum Entropy Model}
\textit{Maximum Entropy} (MaxEnt) merupakan model statistik yang dapat digunakan untuk
melakukan \textit{train} korpus teranotasi dengan Part-Of-Speech (POS) \textit{tag}.
Salah satu aplikasi MaxEnt adalah POS \textit{tagger} yang mana memiliki hasil akurasi
yang lebih baik ketimbang \textit{state-of-the-art}.
Adapun model probabilitasnya didefinisikan dalam $\mathcal{H}\times\mathcal{T}$,
dimana $\mathcal{H}$ adalah himpunan dari kemungkinan kata dan konteks \textit{tag},
atau \say{\textit{history}} (riwayat), dan $\mathcal{T}$ adalah himpunan dari
\textit{tag} yang diizinkan.
Model probabilitas dari suatu \textit{history} $h$ bersama dengan \textit{tag} $t$
didefinisikan dalam persamaan \ref{maxent:equation:1}.

\begin{equation}\label{maxent:equation:1}
  p(h, t) = \pi\mu\prod_{j = 1}^{k} a_{j}^{f_{j}(h, t)}
\end{equation}

\noindent
dimana $\pi$ merupakan konstan normalisasi,
$\{\mu, a_1, \dots, a_k\}$ merupakan parameter model positif,
dan $\{f_1, \dots, f_k\}$ merupakan apa yang kita sebut sebagai
\say{\textit{feature}},
dimana $f_j(h, t) \in \{0, 1\}$.

Meskipun MaxEnt dipernalkan untuk POS \textit{tagging},
MaxEnt dapat pula digunakan untuk \textit{supertagging}.
Stephen Clark 2002 mempublikasikan literatur \textit{supertagging} untuk CCG yang
mana MaxEnt merupakan model yang digunakan.
Adapun persamaan modelnya dapat dilihat di persamaan \ref{maxent:equation:2}.

\begin{equation}\label{maxent:equation:2}
  p(c|h) = \frac{1}{Z(h)} e^{\Sigma_i \lambda_if_i(c, h)}
\end{equation}

\noindent
dimana $c$ merupakan \textit{category}, $h$ merupakan \textit{context},
fungsi $f_i(c, h)$ merupakan \say{\textit{feature}} dari suatu
\textit{category} dan \textit{context}, dan $Z(h)$ merupakan konstan normalisasinya.
Adapun contoh \say{\textit{feature}} yang dimaksud dapat dilihat di persamaan
\ref{maxent:equation:3}.

\begin{equation}\label{maxent:equation:3}
  f_j(c, h) =
  \begin{cases}
    1 &, \text{if } merupakan\_kata\_yang(h) = true\ \&\ c = \text{NP/N}\\
    0 &, \text{selainnya}
  \end{cases}
\end{equation}
